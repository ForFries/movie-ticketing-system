# 电影购票系统

一个基于Vue3+SpringBoot3的电影管理系统

**注意f000f98提交前的工程由于不包含application.yml，所以无法正常启动，请参考f000f98提交中的``application.yml``和``application-dev.yml``进行配置，才能正常进行启动！**

## 技术栈

**后端**: SpringBoot 3 + MyBatis-Plus + MySQL

**前端**: Vue3 + Element-Plus

**缓存**: Redis

**文件存储**: 阿里云OSS

**消息推送**: WebSocket

## 亮点

### 1.异常处理完善:

统一的全局异常处理器

自定义业务异常体系

详细的异常信息

### 2.权限控制严格:

JWT + 拦截器实现

基于注解的细粒度权限控制

影院管理员权限校验

### 3.代码规范:

统一的返回结果封装

分页查询的统一封装

注释规范完整

### 4.安全性考虑:

密码加密存储

Token 认证

权限校验

### 5.创新功能:

微信扫码登录

WebSocket实时通知

座位预订锁机制

### 6.业务逻辑严谨

订单状态流转

座位预订冲突处理

影院管理权限隔离



## 写在前面

我总觉得困难才是让人进步的地方，所以我想先说说这个项目中我遇到的哪些困难

### JS的大整型

在完成整个后端项目时实际上没有遇到什么太大的困难，但是前后端联调的时候（前端也是我写的，借助`cursor`和`Claude3.5`）实际上发现了一些问题，即JavaScript实际上存在整形溢出的情况，他有最大的int大小，而且这个是根植在`axios`或者什么别的地方的（也许是类似于后端那样的反序列器），也就是说json转为js的数据时会发生整型溢出（这是我真的没想到的），而恰巧我所有的ID都是以`BigInt`(SQL)和`Long`(Java)类型存储的，这就很麻烦，实际上有一些解决方案，例如将所有的类型都定义为String（本来以为这样不好，结果这样才是最好的，写多了算法会有这种固执的想法），也可以尝试在JS中引入BigInt这样的类型（但是我发现好像不一定行），当然也可以使用后端的序列化器实现，但是这样我设计的那些接口文档都需要进行更改，很麻烦，所以最后我采用了一个最不咋样但是最快捷的方法，即自己设计一个ID生成器模拟位数较少的雪花算法（实际上也就是模拟）利用时间戳和随机数就可以实现一个可控位数的ID生成



### 锁

锁设计，实际上这是我第一次想到使用锁，我知道在企业中遇到类似多线程的情况下肯定是需要考虑的，但是貌似网上的那些教程并没有很好的利用这样的机制，因为可能他们的项目多半是不会上线的，也很难遇到这样的冲突，但是我想到了类似于大麦那样的系统，在高并发情况下，票是极有可能卖超的，或者是座位是会被多人抢到的，所以我目前在寻找解决方案



#### 面向模板的编程

采用了模板方法模式来处理分页查询，通过定义PageableService接口作为顶层抽象，然后用PageableServiceImpl实现基础的分页逻辑作为模板类，再通过PageableWithCheckService扩展接口增加权限校验功能。具体业务服务类（如MovieService、CinemaService等）通过继承这些基类并实现特定的buildQueryWrapper方法来定制查询条件，从而实现了分页查询逻辑的复用和统一管理，同时保持了足够的灵活性让各个业务模块能够添加自己的查询逻辑。

---

### 梳理一下目前实现功能

#### 管理员端：

管理员端目前后端实现了对电影影院的管理、对影厅、排片的管理，目前需要修改的部分：排片应该新增电影名不然前端就要疯狂访问，其次后端没有实现用户分页的功能，后端没有实现删除等状态的更新（假删除），导致如果有一个信息没有删会导致整个状态出现问题，后端没有实现文件上传功能

#### 用户端

没有实现订单支付功能，没有实现微信登录功能，没有实现取消订单的审核和评论的审核

#### 前端

~~前端没有实现对单个座位更改的功能~~，没有实现websocket传输取消订单的审核通知，~~前端没有实现订单模块~~，前端没有实现快速删除的功能，

## 权限管理

一个系统的关键在于权限管理

本系统分为四种权限：权限由大到小

- 系统管理员
- 影院管理员
- 用户
- 公共

这里的设计是登录认证时下发JWT令牌，令牌载荷payload

```json
{
    userId="1234";
    role="cinema_admin"  //或"system_admin" 或"user"
    cinemaId="112111"    //这里仅在role="cinema_admin"时存在
}
```

**需要系统管理员权限的功能模块**

- 电影管理
- 影院管理
- 评论管理

**需要影院管理员权限的模块**

- 影厅管理（含座位管理）

- 排片管理
- 订单管理

**需要用户权限的模块**

- 订单管理
- 评论管理（暂未实现）

对于这三种不同的权限，设计思路如下：

#### 公共权限

不进行请求拦截

当访问电影信息、影院信息、排片信息、座位信息时

只能访问status为特定值的信息，即可用状态的信息

只有这里对status进行设置

#### User权限

使用拦截器方案

每个请求进入拦截器时，判断是否为用户，是用户则放行

对于订单信息时：查询的所有订单信息均为对应用户Id的信息

对于创建订单时，检查`seatId`对应`ScreeningHall`和`scheduleId`对应`ScreeningHall`是否一致

#### Cinema_Admin权限

使用拦截器方案 + 权限管理方案

对于任意请求，都需要携带`Query`参数`cinemaId`

进入拦截器时，拦截器获取所有请求的`cinemaId`，与`payload`里的参数进行对比，对比通过后放行

对于所有信息的获取和创建，都需要对传入的数据进行合格性检测，例如：

- 对于Schedule的获取，需要知道获取的schedule的`cinemaId`与payload是否一致等

- 对于含有`cinemaId`的修改，需要知道修改的值与`Query`参数的`cinemaId`是否一致

**这里采取的方案是使用切面类，对于需要判断的地方打上`@CinemaIdCheck`的注释，切面类自动获取对应类的`cinemaId`的值（使用反射获取`getCinemaId`方法），同时获取该类的`mapper`层对象，直接进行查询是否有该数据存在数据库**

#### System_Admin权限

使用拦截器方案



### 还未完成的功能

1. ~~微信登陆~~

   新增了微信登陆，流程如下，在登录界面，可使用微信登录，点击微信登陆时会向后端建立websocket通信，链接是：ws://127.0.0.1:8080/login，这个链接应当存储在类似配置的文件中，如解决跨域问题时的配置，方便修改，当建立连接后，后端会发送一个含有二维码的地址，格式如下：{
       "data": "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQG27zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyZENsWlF2NW1kU0YxOXh5Wk5EY08AAgQJoD1nAwRYAgAA",
       "type": "qrcode"
   }，此时需要根据该地址展示出对应的二维码，当用户成功登陆后，后端会发送JWT令牌（通过websocket），格式如下：{
       "data": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoidXNlciIsImNpbmVtYUlkIjoibnVsbCIsInVzZXJJZCI6IjIwOTE5MTkxNTQ4NzE3IiwiZXhwIjoxNzMyMDk5MTE5fQ.sw7yyZ5tNsWf_AU5KSMjP_AOWZsIGGu61ahtFzGwATk",
       "type": "jwt"
   }，此时需要像之前登陆一样，记录下该jwt，用于之后的访问，当收到jwt令牌后，即登录成功，此时可以像使用账户名密码一样正常跳转（分析该jwt然后跳转到对应界面，之前已经实现了该逻辑）

2. 支付系统（下单后转为未支付状态，扫码支付后转为支付状态）

3. ~~评论系统~~



### 需要缓存的数据

1. 电影信息（Status正常）

2. 影院信息

3. ScheduleSeat信息



### 需要WebSocket

1. 审核
2. 取消订单